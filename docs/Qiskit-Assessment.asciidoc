[[qiskit-assessment]]
= An Assessment of the current Qiskit Python code
:toc:
:toc-placement: preamble

An Assessment of the current Qiskit Python code

toc::[]

=== data-types everywhere are either undocumented or poorly documented

=== The RPC layer should be implemented via an RPC compiler and runtime, e.g. Thrift or GRPC

The types of this system are complicated, replete with possibilities
for screwups and inconsistencies.  Other companies have faced such
issues, and have learned that they need to formalize the types of RPC
interfaces using an IDL, and generate the RPC stubs/skeletons
mechanically.

It is easy to see why the lack of the above is problematic: there are
fields all over the system that aren't documented in the JSON schema,
heck not documented *anywhere*.  This *always* produces brittle
systems that are difficult to evolve. *Always*.

Other companies have also noticed that they need to evolve their RPC
interfaces, and (e.g.) both Thrift and GRPC hvae explicit support for
this.

=== The RPC (wireline) API should be documented

It isn't.

=== The RPC API should follow one of the well-estabilished patterns

Today, there are GET requests that carry parameters (even JSON) in the
URL as params.  There are size-limits to this approach.  Meanwhile, in
some POSTS, params are passed as POST content (url-encoded), where for
other POSTs, params are appended to the URL (as with GET) and a JSON
object is passed in the body.

This is incoherent.  The "access_token" is a session-cookie: so treat
it like and pass it as an HTTP Cookie.  OR, get rid of GET entirely,
use only POSTs, and pass all arguments in JSON objects.

But really this is all moot!  You should be using Thrift or GRPC
(preferably Thrift).  Then you wouldn't even be worrying about these
sorts of things!

=== Errors

I've seen cases where application errors (a job that had been in the
queue, but was no longer) got reflected as an authentication error,
instead of an application error.

=== There is an argument to be made for optional fields; that argument does not apply here

=== DAG-based IR considered harmful

=== Python is the wrong language for a nontrivial compiler

Python, like Perl, is unsuitable for writing a nontrivial compiler.
It's weak dynamic typing makes it difficult to write intricate
algorithms with complex data-structures, and living with those
weaknesses requires massive unit-testing that many commentators have
noted basically takes the places of static type-checking in other
languages.

The pervasive presence of many parameters to methods, most of which
are omitted, is also problematic in a complex system -- there's a case
for optional arguments, but they ought to be kept to a minimum.

=== Poor unit-test coverage

There's hardly any unit-testing.  I've stumbled across old
code/function here-and-there, and of course, in the absence of
unit-testing there's no way to tell if that function is supposed to be
used or nt.

=== Timeouts and Retries

I've noticed that the backend infrastructure is pretty unstable.  RPCs
hang more often than they ought.  The Python code appears to retry,
and this is somewhat problematic, esp. for submitting jobs.  If every
job-submission carried a request-id (UUID), it could be used to render
job-submission requests idempotent.

Also, the expected (and normal) RPC time is well in excess of 10sec.
This is really bad for a distributed system, b/c we're edging into the
time-range where network and infrastructure errors can be confused
with "the RPC is just taking a little while".  I think the operators
of the backend need to figure out why these RPCs are taking so long --
there's no good reason why any RPC latency in this system should be
greater than a few seconds.  I mean, you have, what?  200 users?
That's minuscule.  A laptop should be able to handle the RPC traffic.
